from .compat import isclose as isclose, mean as mean
from .mixins import ValuesMixin as ValuesMixin
from collections.abc import Generator
from typing import Any

str: Any

def negated(values) -> Generator[Any, None, None]: ...
def inverted(values, input_min: int = ..., input_max: int = ...) -> Generator[Any, None, None]: ...
def scaled(
    values, output_min, output_max, input_min: int = ..., input_max: int = ...
) -> Generator[Any, None, None]: ...
def scaled_full(values): ...
def scaled_half(values): ...
def clamped(values, output_min: int = ..., output_max: int = ...) -> Generator[Any, None, None]: ...
def absoluted(values) -> Generator[Any, None, None]: ...
def quantized(values, steps, input_min: int = ..., input_max: int = ...) -> Generator[Any, None, None]: ...
def booleanized(values, min_value, max_value, hysteresis: int = ...) -> Generator[Any, None, None]: ...
def all_values(*values) -> Generator[Any, None, None]: ...
def any_values(*values) -> Generator[Any, None, None]: ...
def averaged(*values) -> Generator[Any, None, None]: ...
def summed(*values) -> Generator[Any, None, None]: ...
def multiplied(*values) -> Generator[Any, None, Any]: ...
def queued(values, qsize) -> Generator[Any, None, None]: ...
def smoothed(values, qsize, average=...) -> Generator[Any, None, None]: ...
def pre_delayed(values, delay) -> Generator[Any, None, None]: ...
def post_delayed(values, delay) -> Generator[Any, None, None]: ...
def pre_periodic_filtered(values, block, repeat_after) -> Generator[Any, None, None]: ...
def post_periodic_filtered(values, repeat_after, block) -> Generator[Any, None, None]: ...
def random_values() -> Generator[Any, None, None]: ...
def sin_values(period: int = ...) -> Generator[Any, None, None]: ...
def cos_values(period: int = ...) -> Generator[Any, None, None]: ...
def alternating_values(initial_value: bool = ...) -> Generator[Any, None, None]: ...
def ramping_values(period: int = ...) -> Generator[Any, None, None]: ...
def zip_values(*devices): ...
